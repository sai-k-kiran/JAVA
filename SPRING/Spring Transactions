Transaction in JDBC:

    Connection connection = dataSource.getConnection();

    try (connection) {
        connection.setAutoCommit(false);
        // ...
        connection.commit(); 

    } catch (SQLException e) {
        connection.rollback(); 
    }

autoCommit flag is valid for the whole time your connection is open, which means you only need to call the method once, not repeatedly.
Plain JDBC you only have one way (setAutocommit(false)) to manage transactions, Spring offers you many different, more convenient ways to achieve the same.

How to use Spring’s Programmatic Transaction Management?
A less used way to define transactions in Spring is programmatically: Either through a TransactionTemplate or directly through the PlatformTransactionManager.

@Service
public class UserService {

    @Autowired
    private TransactionTemplate template;

    public Long registerUser(User user) {
        Long id = template.execute(status ->  {
            // execute some SQL inserts something into the db & returns the autogenerated id
            return id;
        });
    }
}

- You do not have to mess with opening or closing database connections yourself (try-finally). Instead you use Transaction Callbacks.

- You also do not have to catch SQLExceptions, as Spring converts these exceptions to runtime exceptions for you.

- And you have better integration into the Spring ecosystem. TransactionTemplate will use a TransactionManager internally, which will use a data source. All are beans 
    that you have to specify in your Spring context configuration, but then don’t have to worry about anymore later on.

How to use Spring’s @Transactional annotation ( Declarative Transaction Management )

    public class UserService {

        @Transactional   // Can be used above a service class or a method
        public Long registerUser(User user) {
            // execute some SQL inserts something into the db & returns the autogenerated id
            return id;
        }
    }

    @Configuration          // Configuration class. 
    @EnableTransactionManagement   // This annotation can also be added above Main class. This will create a PlatformTransactionManager
    public class MySpringConfig {

        @Bean
        public PlatformTransactionManager txManager() {
            return yourTxManager; 
        }
    }

- Make sure that your Spring Configuration is annotated with the @EnableTransactionManagement annotation (In Spring Boot this will be done automatically for you).
- Make sure you specify a transaction manager in your Spring Configuration (this you need to do anyway).
- Any bean’s public method you annotate with the @Transactional annotation, will execute inside a database transaction

Underneath, @Transactional annotated class works same as the plain JDBC transaction. It will convert the code to try(connection)... code like the JDBC code above.

When the "UserService" is Autowired in any controller/classes, a proxy of UserService(original too) is created & used by those classes. It does that through a method 
called "proxy-through-subclassing" with the help of the Cglib library. There are also other ways to construct proxies (like Dynamic JDK proxies)

If Spring detects the @Transactional annotation on a bean, it creates a dynamic proxy of that bean.
The proxy has access to a transaction manager (which is the PlatformTransactionManager in Spring Boot) and will ask it to open and close transactions/connections.
The transaction manager itself will simply use a good, old JDBC connection.

The proxy does: Opening and closing database connections/transactions.
And then delegating to the real UserService, the one you wrote.
And other beans, like your UserRestController will never know that they are talking to a proxy, and not the real thing.

For what do you need a Transaction Manager (like PlatformTransactionManager)?

UserService gets proxied on the fly, and the proxy manages transactions for you. But it is not the proxy itself handling all this transactional state (open, commit, 
close), the proxy delegates that work to a transaction manager.

Spring offers a PlatformTransactionManager(super: TransactionManager) interface which comes with a couple of implementations. One of them is the "DatasourceTransactionManager"

@Bean
public DataSource dataSource() { 
    return new MysqlDataSource();  // create a db-specific or connection-pool specific datasource here
}

@Bean
public PlatformTransactionManager txManager() {
    return new DataSourceTransactionManager(dataSource());  // create a transaction manager, which needs a data source to be able to manage transactions.
}

Spring Boot automatically sets the @EnableTransactionManagement annotation and creates a PlatformTransactionManager for you - with its JDBC auto-configurations.

In Spring + Hibernate/JPA project, we will be using HibernateTransactionManager(or JPATransactionManager for JPA)
-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

What is the difference between physical and logical transactions?

    @Service
    public class UserService {
        @Autowired
        private InvoiceService invoiceService;

        @Transactional
        public void invoice() {
            invoiceService.createPdf();
            // send invoice as email, etc.
        }
    }

    @Service
    public class InvoiceService {
        @Transactional
        public void createPdf() {
            // ...
        }
    }
UserService has a transactional invoice() method. Which calls another transactional method, createPdf() on the InvoiceService.

In terms of db transactions, this should really just be one db transaction(getConnection(), setAutocommit(false), commit()), Spring calls this physical transaction
From Spring’s side however, there’s two logical transactions happening: First in UserService, the other one in InvoiceService. Spring has to be smart enough to 
know that both @Transactional methods, should use the same underlying, physical database transaction.

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createPdf() {
            // ...
    }

Propagation mode "requires_new" is telling Spring that createPDF() needs to execute in its own transaction, independent of any other already existing transaction.
Which basically means your code will open two (physical) connections/transactions to the db. Spring now has to be smart enough that the two logical transactional 
pieces (invoice()/createPdf()) now also map to two different, physical database transactions.

-Physical Transactions: Are your actual JDBC transactions.
-Logical Transactions: Are the (potentially nested) @Transactional-annotated (Spring) methods.

What are @Transactional Propagation Levels used for?
    @Transactional(propagation = Propagation.REQUIRED)

The full list:
1. REQUIRED (default) -  Spring checks if there is an active transaction, and if nothing exists, it creates a new one. Otherwise, the business logic appends to 
the currently active transaction.

2. SUPPORTS  -  Spring first checks if an active transaction exists. If a transaction exists, then the existing transaction will be used. If there isn’t a transaction, 
it is executed non-transactional.

3. MANDATORY  - if there is an active transaction, then it will be used. If there isn’t an active transaction, then Spring throws an IllegalTransactionStateException

4. REQUIRES_NEW  - Spring suspends the current transaction if it exists, and then creates a new one. Needs the JTATransactionManager for actual transaction suspension.

5. NOT_SUPPORTED -  If a current transaction exists, first Spring suspends it, and then the business logic is executed without a transaction. The JTATransactionManager 
supports real transaction suspension out-of-the-box. Others simulate the suspension by holding a reference to the existing one and then clearing it from the thread context

6. NEVER - For transactional logic with NEVER propagation, Spring throws an "IllegalTransactionStateException" if there’s an active transaction.

7. NESTED - Spring checks if a transaction exists, and if so, it marks a save point. This means that if our business logic execution throws an exception, then the 
transaction rollbacks to this save point. If there’s no active transaction, it works like REQUIRED.

DataSourceTransactionManager supports this propagation out-of-the-box. Some implementations of JTATransactionManager may also support this. 

JpaTransactionManager supports NESTED only for JDBC connections. However, if we set the nestedTransactionAllowed flag to true, it also works for JDBC access code in 
JPA transactions if our JDBC driver supports save points.
-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

Transaction Isolation:

Isolation is one of the common ACID properties. Isolation describes how changes applied by concurrent transactions are visible to each other.

Each isolation level prevents zero or more concurrency side effects on a transaction:

    - Dirty read: read the uncommitted change of a concurrent transaction      // all these are concurrency side effects.
    - Non-repeatable read: get different value on re-read of a row if a concurrent transaction updates the same row and commits
    - Phantom read: get different rows after re-execution of a range query if another transaction adds or removes some rows in the range and commits

We can set the isolation level of a transaction by @Transactional::isolation. It has these five enumerations in Spring: DEFAULT, READ_UNCOMMITTED, READ_COMMITTED, 
REPEATABLE_READ, SERIALIZABLE.

The default isolation level is DEFAULT. As a result, when Spring creates a new transaction, the isolation level will be the default isolation of our RDBMS. 
Therefore, we should be careful if we change the db.

We should also consider cases when we call a chain of methods with different isolation. In the normal flow, the isolation only applies when a new transaction is created.
Thus, if for any reason we don’t want to allow a method to execute in different isolation, we have to set TransactionManager::setValidateExistingTransaction to true.

- READ_UNCOMMITTED Isolation
READ_UNCOMMITTED is the lowest isolation level and allows for the most concurrent access. As a result, it suffers from all three mentioned concurrency side effects. 
A transaction with this isolation reads uncommitted data of other concurrent transactions. Also, both non-repeatable and phantom reads can happen. Thus we can get a 
different result on re-read of a row or re-execution of a range query.

    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public void log(String message) {
        // ...
    }

Postgres does not support READ_UNCOMMITTED isolation and falls back to READ_COMMITED instead. Also, Oracle does not support or allow READ_UNCOMMITTED.

- READ_COMMITTED Isolation
The second level of isolation, READ_COMMITTED, prevents dirty reads. The rest of the concurrency side effects could still happen. So uncommitted changes in concurrent 
transactions have no impact on it, but if a transaction commits its changes, our result could change by re-querying.

    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void log(String message){
        // ...
    }

READ_COMMITTED is the default level with Postgres, SQL Server, and Oracle.

- REPEATABLE_READ Isolation
REPEATABLE_READ, prevents dirty & non-repeatable reads. So we are not affected by uncommitted changes in concurrent transactions. 
Also, when we re-query for a row, we don’t get a different result. However, in the re-execution of range-queries, we may get newly added or removed rows.

Moreover, it is the lowest required level to prevent the lost update. The lost update occurs when two or more concurrent transactions read and update the same row. 
REPEATABLE_READ does not allow simultaneous access to a row at all. Hence the lost update can’t happen.

    @Transactional(isolation = Isolation.REPEATABLE_READ) 

REPEATABLE_READ is the default level in Mysql. Oracle does not support REPEATABLE_READ.

- SERIALIZABLE Isolation
SERIALIZABLE is the highest level of isolation. It prevents all mentioned concurrency side effects, but can lead to the lowest concurrent access rate because it 
executes concurrent calls sequentially. In other words, concurrent execution of a group of serializable transactions has the same result as executing them in serial.

    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void log(String message){
        // ...
    }

-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

@Service
public class UserService {

    @Transactional
    public void invoice() {
        createPdf();
        // send invoice as email, etc.
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createPdf() {
        // ...
    }
}

The UserService class will create 1 physical transaction but 2 logical transactions. Spring creates that transactional UserService proxy for you, but once you are 
inside the UserService class and call other inner methods, there is no more proxy involved. This means, no new transaction for you.

Customizing rollback behaviors: We can customize rollbach behavior using "rollback" or "noRollback" properties of @Transactional annotation:

    @Service
    @Transactional(noRollbackFor = RuntimeException.class)  //  RuntimeException should not trigger a rollback
    public class UserService { 
        // ...
    }

@Transactional works only on public methods. Spring creates a proxy around public methods to manage transactional behaviour. Private methods are not visible to the proxy and cannot be wrapped in a transactional context.